## Обратный прокси

#### :white_check_mark: _Пример конфигурации для проксирования запросов на бэкенд-сервер:_

```ruby
server {
    listen 80;
    server_name your-domain.com;  # или IP-адрес сервера
	
    #listen 443 ssl;
    #server_name your-domain.com;

    #ssl_certificate /path/to/cert.pem;
    #ssl_certificate_key /path/to/key.pem

    location / {
        proxy_pass http://localhost:3000;  # адрес и порт вашего бэкенд-сервера
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}
```

#### :white_check_mark: _Если вам нужно проксировать несколько сервисов, можно использовать разные location или поддомены._

```ruby
server {
    listen 80;
    server_name api.your-domain.com;

    location / {
        proxy_pass http://localhost:8080;
        # ... proxy_set_header
    }
}

server {
    listen 80;
    server_name app.your-domain.com;

    location / {
        proxy_pass http://localhost:3000;
        # ... proxy_set_header
    }
}
```

#### :white_check_mark: Рабочий вариант

Для теста на своих двух тачках поставил Nginx и сделал следующее. На сервере testkedo_v1.mosinzhproekt.ru (192.168.11.129) настроил Nginx следующим образом.

```ruby
grep -v -E '^\s*#|^\s*$' /etc/nginx/sites-available/default | sed 's/#.*$//'
grep -v -E '^\s*#|^\s*;|^\s*$' /etc/php/8.2/fpm/php.ini | sed 's/;.*$//'

Разбор по частям:

grep – утилита для поиска текста по шаблону.

-v – инвертирует поиск (выводит строки, которые НЕ соответствуют шаблону).
-E – включает расширенные регулярные выражения (ERE).
'^\s*#|^\s*$' – шаблон для фильтрации строк:
^\s*# – строки, начинающиеся с # (комментарии), возможно, с пробелами перед #.
| – логическое ИЛИ.
^\s*$ – пустые строки (даже если они содержат пробелы).


s/pattern/replacement/ – команда замены (substitute).

#.*$ – шаблон:
# – символ решётки (начало комментария).
.* – любое количество любых символов после #.
$ – конец строки.
// – замена на пустую строку (удаление).

Итог: Удаляет всё, что идёт после # до конца строки, включая сам символ #.
```

![image](https://github.com/user-attachments/assets/ea3419e7-dcb6-42e7-ae12-eb8226115310)

```ruby
# force redirect http to https
rewrite ^ https://$http_host$request_uri? permanent;
```

#### :white_check_mark: Проверка сертификата

```ruby
# Проверка серта используя openssl (универсальный способ)
openssl x509 -noout -dates -in /etc/nginx/ssl/mosinzhproekt_ru_2025_09_16.crt

# Проверить сертификат на удалённом сервере
openssl s_client -connect disk.mosinzhproekt.ru:443 -servername disk.mosinzhproekt.ru 2>/dev/null | openssl x509 -noout -dates

# Проверить сразу весь цепочку сертификатов
openssl s_client -connect disk.mosinzhproekt.ru:443 -showcerts 2>/dev/null | openssl x509 -noout -dates -nameopt multiline
```

При заходе на сервер testkedo_v1.mosinzhproekt.ru запросы уходят на сервер http://192.168.11.110 и весь контент тянется оттуда. Домен testkedo_v1.mosinzhproekt.ru работает по https, а http://192.168.11.110 по https не может. В браузерной строке отображается домен testkedo_v1.mosinzhproekt.ru. 

<br>

## Директива proxy_set_header

### :white_check_mark: Что такое `proxy_set_header`?

`proxy_set_header` — это директива модуля `ngx_http_proxy_module`, которая позволяет переопределять или добавлять заголовки HTTP-запроса перед тем, как этот запрос будет передан (проксирован) на backend-сервер.

### Зачем это нужно и ключевые функции обратного прокси?

Обратный прокси в Nginx — это архитектурная роль, которую выполняет Nginx, выступая посредником между клиентами (браузерами) и внутренними серверами (приложениями). Он принимает запросы от клиентов, перенаправляет их на соответствующие внутренние серверы (например, веб-приложения, API или другие сервисы), а затем возвращает ответы клиентам. Для клиентов это выглядит так, будто ресурсы находятся непосредственно на самом Nginx, что скрывает структуру внутренней сети

Бэкенд-приложению (например, PHP, Python, Node.js) часто критически важна информация из оригинального запроса клиента: его реальный IP-адрес, какой домен он запрашивал, используемый протокол (HTTP/HTTPS) и т.д. По умолчанию, при проксировании, эта информация теряется, и бэкенд видит только IP-адрес самого NGINX. `proxy_set_header` решает эту проблему.

**Балансировка нагрузки**

1. Nginx распределяет входящие запросы между несколькими серверами, предотвращая перегрузку отдельных узлов и повышая отказоустойчивость. Например, можно настроить распределение по алгоритму round-robin или least connections

2. Пример конфигурации:

```ruby
upstream backend {
    server backend1.example.com;
    server backend2.example.com;
}
server {
    location / {
        proxy_pass http://backend;
    }
}
```


**Повышение безопасности**

1. Скрытие внутренней инфраструктуры: IP-адреса внутренних серверов остаются недоступными извне.
2. Защита от атак: Nginx может фильтровать вредоносные запросы, блокировать IP-адреса и обеспечивать HTTPS-шифрование.
3. _Важно_: Nginx часто обрабатывает SSL/TLS-шифрование (termination), разгружая внутренние серверы

**Кэширование и оптимизация производительности**

1. Nginx кэширует статический контент (изображения, CSS, JS), уменьшая нагрузку на внутренние серверы и ускоряя ответы для клиентов.
2. Поддерживает сжатие данных (gzip) и буферизацию запросов

**Единая точка входа**

1. Nginx предоставляет единый публичный IP/домен для доступа к множеству внутренних сервисов. Это упрощает управление доменами и сертификатами.
2. Пример: Можно настроить маршрутизацию на основе домена или пути URL (например, `example.com/app1` → сервер 1, `example.com/app2` → сервер 2).

**Поддержка SSL/TLS**

1. Nginx управляет SSL-сертификатами (например, с помощью Let's Encrypt), обеспечивая безопасное соединение между клиентом и прокси, mientras внутренние серверы могут общаться по HTTP

**Гибкая маршрутизация запросов**

1. Nginx позволяет перенаправлять трафик на основе правил, таких как URL, заголовки запроса или тип контента. Это полезно для A/B-тестирования, канареечных развертываний или обслуживания разных версий AP

#### Синтаксис и расположение

```ruby
# Директива может быть указана в контекстах: http, server, location.
proxy_set_header Header_Name Header_Value;
```

### Основные и самые важные виды и значения

Вот самые распространенные заголовки, которые переопределяют с помощью `proxy_set_header`:

#### 1. `X-Real-IP` (или `X-Forwarded-For`)

`X-Real-IP` — это не стандартный HTTP-заголовок, а кастомный (пользовательский) заголовок, который широко используется в веб-инфраструктуре, особенно за обратными прокси (такими как Nginx), чтобы передать внутреннему серверу (приложению) реальный IP-адрес клиента, который сделал исходный запрос.

_Пример:_

1). Клиент с IP-адресом `123.123.123.123` отправляет запрос на Nginx.
2). Nginx, в свою очередь, перенаправляет этот запрос (используя `proxy_pass`) на внутренний сервер.
3). **Но!** Для внутреннего сервера соединение приходит уже от Nginx, а не от исходного клиента. Это значит, что в поле REMOTE_ADDR (стандартное поле, в котором приложение ожидает увидеть IP клиента) будет IP-адрес самого сервера Nginx (например, 127.0.0.1 или 192.168.1.10).

**Итог**: Приложение "видит" все запросы как пришедшие от Nginx и **теряет информацию о реальном пользователе**. Это ломает логирование, системы проверки доступа, аналитику и т.д.

**Проблема**: Бэкенд видит IP-адрес NGINX, а не реального клиента.  
**Решение**: Передать реальный IP-клиента в специальном заголовке.

```ruby
location / {
    proxy_pass http://backend_server;
    proxy_set_header X-Real-IP $remote_addr;
}

Клиент (IP: 123.123.123.123) --> Nginx (обратный прокси) --> Внутренний сервер/Приложение (например, Node.js, PHP, Python)

# $remote_addr — встроенная переменная NGINX, содержащая IP-адрес клиента.
```

** `$remote_addr` — это встроенная переменная Nginx, которая всегда содержит IP-адрес клиента, от которого пришел запрос.
** `X-Real-IP` — это произвольное имя заголовка (соглашение), куда мы помещаем этот IP.

Теперь, когда запрос дойдет до внутреннего сервера (например, вашего PHP или Node.js приложения), он сможет прочитать IP-адрес клиента из заголовка `X-Real-IP`, а не полагаться на REMOTE_ADDR.

`X-Real-IP` **vs** `X-Forwarded-For`

Часто вместе с `X-Real-IP` используют и другой заголовок — `X-Forwarded-For` (XFF). Они решают одну задачу, но по-разному:


**Более распространенный и надежный подход — использование** `X-Forwarded-For`: Этот заголовок содержит цепочку всех прокси-серверов, через которые прошел запрос.

```ruby
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
```

**Какой использовать?** Часто используют оба для совместимости. `X-Real-IP` — как основной надежный источник, а `X-Forwarded-For` — для дополнительной информации или если за Nginx есть еще один прокси.




#### 2. Host

Переменная `$host` в Nginx предназначена для получения хоста (доменного имени или IP-адреса) из входящего HTTP-запроса. Её значение формируется в следующем порядке приоритета.

- **Имя хоста из строки запроса** (если строка запроса содержит полный URL, например, GET http://example.com/ HTTP/1.1).
- **Значение заголовка** Host из HTTP-запроса, который отправляется клиентом (например, Host: example.com).
- **Имя сервера** ( `server_name` ), которое соответствует обрабатываемому запросу в конфигурации Nginx.

Если ни один из этих источников не предоставляет допустимое имя хоста, значение $host будет пустой строкой.

**Проблема**: По умолчанию NGINX при проксировании устанавливает заголовок `Host` равным имени бэкенд-сервера из директивы `proxy_pass` (например, my_backend). Но вашему приложению (например, виртуальному хосту на Apache) нужно знать, какой домен изначально запрашивал клиент.  
**Решение:** Передать оригинальный заголовок `Host`.

```ruby
location / {
    proxy_pass http://backend_server;
    proxy_set_header Host $host;
}
```

- `$host` — переменная, содержащая имя сервера из оригинального запроса (предпочтительнее, так как обрабатывает случай без порта).
- `$http_host` — содержит точное значение заголовка Host из HTTP-запроса. (передает значение с портом, если он был указан. Например, `example.com:8080`).
- `$server_name` — содержит значение директивы server_name из конфигурации Nginx, которое соответствовало запросу. **Всегда определяется конфигурацией Nginx**, а не запросом клиента.





#### 3. X-Forwarded-Proto

**Проблема:** Если NGINX принимает запросы по HTTPS, а с бэкендом общается по HTTP, то приложение не знает, что исходное соединение было защищенным. Это ломает генерацию правильных URL (они будут `http://...` вместо `https://...` ).  
**Решение:** Сообщить бэкенду о протоколе оригинального запроса.

```ruby
location / {
    proxy_pass http://backend_server;
    proxy_set_header X-Forwarded-Proto $scheme;
}
```

`$scheme` — переменная NGINX, содержащая протокол запроса ( `http` или `https` ).

> Заголовки, начинающиеся с X-Forwarded-* (как X-Forwarded-Host, X-Forwarded-For, X-Forwarded-Proto), широко распознаются и автоматически используются многими бэкенд-фреймворками и приложениями (например, Django, Rails, Express.js с настройкой trust proxy).


#### 4. X-Forwarded-Host

**Проблема:** Иногда заголовок `Host` может быть изменен или его недостаточно.  
**Решение:** Передать оригинальное имя хоста в отдельном, специально предназначенном для этого заголовке.

```ruby
proxy_set_header X-Forwarded-Host $host;
```

> Заголовки, начинающиеся с X-Forwarded-* (как X-Forwarded-Host, X-Forwarded-For, X-Forwarded-Proto), широко распознаются и автоматически используются многими бэкенд-фреймворками и приложениями (например, Django, Rails, Express.js с настройкой trust proxy).



#### 5. X-Forwarded-Port

**Проблема:** Приложению может быть нужен номер порта, на который пришел оригинальный запрос (особенно если это нестандартный порт, например, 8080).  
**Решение:**

```ruby
proxy_set_header X-Forwarded-Port $server_port;
```

> Заголовки, начинающиеся с X-Forwarded-* (как X-Forwarded-Host, X-Forwarded-For, X-Forwarded-Proto), широко распознаются и автоматически используются многими бэкенд-фреймворками и приложениями (например, Django, Rails, Express.js с настройкой trust proxy).



#### Практический пример конфигурации

Вот как обычно выглядит стандартный блок location для проксирования на бэкенд-приложение (например, Node.js, Django, Flask).

```ruby
server {
    listen 80;
    server_name myapp.com;

    # Статику отдаем напрямую из NGINX (эффективнее)
    location /static/ {
        alias /path/to/your/static/files/;
    }

    # Все динамические запросы проксируем на бэкенд
    location / {
        # Адрес бэкенд-сервера или upstream-блока
        proxy_pass http://localhost:3000;

        # Стандартный набор заголовков для правильной работы приложения
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Forwarded-Host $host;

        # Опционально: таймауты для избежания "висящих" соединений
        proxy_connect_timeout       60s;
        proxy_send_timeout          60s;
        proxy_read_timeout          60s;

        # Опционально: отключить буферизацию для Server-Sent Events/WebSocket
        # proxy_buffering off;
    }
}
```

#### Что происходит "под капотом"?

1. **Клиент** (1.2.3.4) делает запрос: `GET / HTTP/1.1 Host: myapp.com`
2. **NGINX** принимает этот запрос.
3. **NGINX** формирует **новый запрос** к бэкенду на `localhost:3000`.
4. Благодаря директивам `proxy_set_header`, новый запрос будет содержать:

```ruby
GET / HTTP/1.1
Host: myapp.com
X-Real-IP: 1.2.3.4
X-Forwarded-For: 1.2.3.4
X-Forwarded-Proto: http
X-Forwarded-Host: myapp.com
```

5. **Бэкенд-приложение** ( `localhost:3000` ) видит эти заголовки и понимает, что исходный запрос пришел от клиента `1.2.3.4` на домен `myapp.com`.



#### Важное замечание о безопасности

Заголовки, начинающиеся с `X-Forwarded-*`, являются де-факто стандартом, но они **доверенные**. Ваше бэкенд-приложение **должно быть сконфигурировано так, чтобы доверять этим заголовкам только от вашего NGINX-прокси**.

Если злоумышленник сможет напрямую обратиться к вашему бэкенду, он может подделать эти заголовки. Способы обезопаситься:

1. Настроить брандмауэр, чтобы к бэкенду мог обращаться только NGINX.
2. В самом приложении проверять IP-адрес отправителя (например, в Django для этого есть настройка `USE_X_FORWARDED_HOST = True` и `SECURE_PROXY_SSL_HEADER` ).
3. Можно использовать модуль `ngx_http_realip_module`, чтобы заставить NGINX самому "верить" заголовкам `X-Forwarded-For` от доверенных прокси (более сложная настройка).

**Вывод:** `proxy_set_header` — это ключевой инструмент для корректной и безопасной работы связки NGINX + Backend, который ensures, что бэкенд получает всю необходимую контекстную информацию о первоначальном запросе.



#### :white_check_mark: Итоговый "золотой стандарт" конфигурации

```ruby
location / {
    proxy_pass http://localhost:3000;

    # БАЗОВЫЙ НАБОР ДЛЯ КОРРЕКТНОЙ РАБОТЫ
	
	# Обязательно: для правильной маршрутизации на бэкенде
    proxy_set_header Host               $host;
	
	# $remote_addr — переменная Nginx, которая содержит IP-адрес клиента, от которого пришел запрос
    proxy_set_header X-Real-IP          $remote_addr;
	
	# Содержит цепочку всех прокси-серверов, через которые прошел запрос.
    proxy_set_header X-Forwarded-For    $proxy_add_x_forwarded_for;
	
	# Сообщить бэкенду о протоколе оригинального запроса для генерации правильных URL.
    proxy_set_header X-Forwarded-Proto  $scheme;

    # ОПЦИОНАЛЬНО, НО РЕКОМЕНДУЕТСЯ ДЛЯ ПОЛНОТЫ КОНТЕКСТА
	
	# Рекомендуется: для предоставления полного контекста
    proxy_set_header X-Forwarded-Host   $host;
    proxy_set_header X-Forwarded-Port   $server_port;

	# Опционально: таймауты для избежания "висящих" соединений
	proxy_connect_timeout       60s;
	proxy_send_timeout          60s;
	proxy_read_timeout          60s;

	# Опционально: отключить буферизацию для Server-Sent Events/WebSocket
	# proxy_buffering off;
}
```



